------------------------------------------------------------------------------------------------
-- xPLGirder is a Girder component to connect Girder to an xPL network.<br/>
-- <br/>This handler works with the <a href="http://www.thijsschreijer.nl/blog/?tag=upnp">UPnP-2-xPL gateway</a>, the gateway must be installed to make
-- the handler work (not necessarily on the same system, but within the same network/subnet).
-- The handler will enable Girder to receive value updates from, and to execute methods on UPnP
-- devices. It is highly recommended to read the UPnP Device Architecture 1.1 (see <a href="http://www.upnp.org">www.upnp.org</a>)
-- specifically section 2.3 onwards. And to install the <a href="http://opentools.homeip.net/dev-tools-for-upnp">Developer tools for UPnP</a>,
-- which is an essential set of tools and utilities for UPnP development.<br/>
-- <br/>The handler will create a global table <code>UPnP</code>. This table has two important sub-tables;
-- <ul><li><code>UPnP.devices</code> which contains a hierarchical tree of UPnP devices and their underlying components (services, subdevices, etc.)</li>
-- <li><code>UPnP.IDlist</code> this list contains all elements of the hierarchical tree by their ID</li></ul><br/>
-- An important note to the hierarchical tree is that the <code>key</code>s of the devices and services are their unique
-- names, but adapted for proper display in Girder. The Girder variable inspector will not properly display keys that contain
-- either '.' (dot) or ':' (colon) characters, hence they will be replaced by '_' (underscore). So it cannot be assumed that the key is
-- equal to the device/service unique name.
-- <br/>The UPnP elements that will be listed are;<ul>
-- <li>devices</li>
-- <li>services</li>
-- <li>statevariables</li>
-- <li>methods</li>
-- <li>arguments</li>
-- </ul>Each element has its own ID and has a property <code>parent</code> that contains the ID of the parent element.
-- Each parent has a property <code>IDlist</code> with a list of child IDs. <strong>Note:</strong> the IDs are NOT persistent! When
-- Girder exits or the UPnP device leaves, the ID will be lost. To identify
-- the same device over multiple sessions you should use the unique names of devices and services (see code examples below).<br/>
-- Each value update reported by a UPnP device as well as UPnP devices arriving/leaving will result in a
-- Girder event. The variable updates only arrive if the statevariable is 'evented'. Unevented values may be requested using the <code>poll</code> method.
-- UPnP methods can be executed using the <code>execute</code> method.<br/>
-- <br/>For a tutorial on using UPnP from Girder see <a href="http://www.thijsschreijer.nl/blog/?p=569">this blog post</a>.<br/>
-- <br/>xPLGirder is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
-- xPLGirder is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License
-- along with xPLGirder.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.
-- <br/><br/>
-- See the accompanying ReadMe.txt file for additional information.
-- @copyright 2011-2012 Richard A Fox Jr., Thijs Schreijer
-- @release Version 0.1.6, xPLGirder.

require 'Classes.DelayedExecutionDispatcher'
require 'thread'
require 'date'

local xPLEventDevice = 10124	-- when raising events, use this as source to set it to xPLGirder

local GetValueByKey = function (msg, key)
	-- get a value from the message at hand by its key (the first occurence of that key)
	assert(type(msg) == "table", "Expected table for 'msg'; " .. debug.traceback())
	for k,v in ipairs(msg.body) do
		if v.key == key then
			return v.value
		end
	end
end

local CleanKey = function (key)
	if type(key) == "string" then
		key = string.gsub(key, '%.', '_' )  -- remove any '.' (dot) as the variable inspector will not show tables with them
		key = string.gsub(key, '%:', '_' )  -- remove any ':' (dot) as the variable inspector will not show tables with them
	end
	return key
end

local announcementtimeout = 3000       -- seconds after which to re-request missing parts

local el	-- trick luadoc
-------------------------------------------------------------------------------------------
-- Girder events generated by the UPnP handler. All events will have "xPLGirder" as the
-- event source.
-- @name UPnP events
-- @class table
-- @field arriving Whenever a new UPnP device arrives the following event is raised. Note that
-- 3 seconds after the event automatically a variable update request will be sent.<ul>
-- <li><code>eventstring</code>: "UPnP device arrived; &ltdevice name&gt"</li>
-- <li><code>pld1</code>: device ID assigned to the device</li>
-- <li><code>pld2</code>: nil</li>
-- <li><code>pld3</code>: nil</li>
-- <li><code>pld3</code>: nil</li>
-- </ul>
-- @field leaving Whenever a UPnP device leaves the following event is raised. Note that
-- the device has already been removed from the list when the event is raised.<ul>
-- <li><code>eventstring</code>: "UPnP device left; &ltdevice name&gt"</li>
-- <li><code>pld1</code>: device ID assigned to the device</li>
-- <li><code>pld2</code>: nil</li>
-- <li><code>pld3</code>: nil</li>
-- <li><code>pld3</code>: nil</li>
-- </ul>
-- @field updates Whenever an update of a UPnP variable arrives (automatically for evented variables
-- or upon request for non-evented variables) the following event is raised.<ul>
-- <li><code>eventstring</code>: "UPnP value update &ltdevice name&gt:&ltvariable name&gt"</li>
-- <li><code>pld1</code>: ID of the variable that changed</li>
-- <li><code>pld2</code>: new value of the variable</li>
-- <li><code>pld3</code>: old value of the variable</li>
-- <li><code>pld3</code>: nil</li>
-- </ul>
el = {}
el = nil

local myNewHandler = {

	ID = "UPnP",		-- enter a unique string to identify this handler

	Filters = {
		"*.*.*.*.upnp.basic",
		"*.*.*.*.upnp.announce",
		"*.*.*.*.upnp.method",
		"*.*.*.*.hbeat.end",
		"*.*.*.*.config.end",
	},

	Initialize = function (self)
		-- function called upon initialization of this handler
		--print ("Initializing the xPL handler ID: " .. self.ID)

		-- define global tables
		UPnP = {
			IDlist = self.IDlist,
			devices = self.DevList,
			-----------------------------------------------------------------------------------------
			-- Calls a UPnP method. The call is synchroneous and will (wait for) and return the results
			-- (eventhough the communications are asynchroneous, both xPL and UPnP). There is a fixed
			-- timeout of 20 seconds if the UPnP device does not respond.<br/>There are 2 ways to call
			-- a method; 1) directly on the method table, 2) indirectly using a generic call. See the
			-- example below for the difference, the results will be identical.
			-- @name UPnP.CallMethod
		    -- @param methodid The ID of the method to execute
			-- @param ... parameters for the method, all parameters MUST be provided for the call to succeed
		    -- @return success (boolean) <code>true</code> if the call was succesfull, if it failed, the
			-- second return value will contain the error.
			-- @return additional return values are all the OUT arguments of the method
			-- @usage# -- The ID's below are fixed, and will not change over time (but might after firmware update)
			-- local RecivaUUID = "c29e7602-328f-444d-911c-7cdc8bc74768"
			-- local RadioServiceID = "urn_reciva-com_serviceId_RecivaRadio"
			-- -- Get method "GetPlaybackDetails" from the device/service
			-- local m = UPnP.devices[RecivaUUID].services[RadioServiceID].methods["GetPlaybackDetails"]
			-- &nbsp
			-- -- method1: call directly on method table (must provide each argument, even though not used!)
			-- local success, result = m:execute("", "")
			-- &nbsp
			-- -- method2: call indirectly using generic call (must provide each argument, even though not used!)
			-- local success, result = UPnP:CallMethod(m.ID, "", "")	-- m.ID additional argument needed here
			CallMethod = function (self, methodid, ...)
					methodid = (methodid or "") .. ""	-- convert to string
					local method = self.IDlist[methodid]
					if method == nil then
						error("No (valid) method provided, first argument must be method id, remaining arguments the parameters to the method.", 2)
					end
					return method:execute(unpack(arg))
				end,
			-----------------------------------------------------------------------------------------
			-- Requests current value of a device, service or variable. In case of a variable only
			-- a single value will be requested, in case of a device or service the values off all
			-- underlying variables (within nested devices/services) will be requested. The request
			-- will be executed asynchroneously, the updates will come in as regular value updates.
			-- <br/><strong>Important note</strong>: UPnP does not provide a way to request variable
			-- values. The UPnP-2-xPL gateway provides a rudimentary workaround, which quite often
			-- won't work. See the gateway documentation for details on what to expect.
			-- <br/>There are 2 ways to request a value;
			-- 1) directly on the service/device/variable table, 2) indirectly using a generic call. See the
			-- example below for the difference, the results will be identical.
			-- @name UPnP.PollValue
			-- @param id The ID of the device, service or variable for which the update is requested.
			-- @return Nothing
			-- @usage# -- The ID's below are fixed, and will not change over time (but might after firmware update)
			-- local RecivaUUID = "c29e7602-328f-444d-911c-7cdc8bc74768"
			-- local RadioServiceID = "urn_reciva-com_serviceId_RecivaRadio"
			-- -- Get the service from the device table, the request on a service will return all variables within it
			-- local s = UPnP.devices[RecivaUUID].services[RadioServiceID]
			-- &nbsp
			-- -- method1: call directly on service/device/variable table
			-- s:poll()
			-- &nbsp
			-- -- method2: call indirectly using generic call
			-- UPnP:PollValue(s.ID)	-- s.ID additional argument needed here
			PollValue = function (self, id)
					id = (id or "") .. "" -- convert to string
					if id == "" then
						error ("No ID provided for the element whose values to poll")
					end
					local elem = self.IDlist[id]
					if elem == nil then
						error ("ID '" .. id .. "' is not valid for polling variables values")
					end
					if type(elem.poll) ~= "function" then
						error ("ID '" .. id .. "' is not valid for polling variables values")
					end
					elem:poll()
				end,
		}

		-- send announce request, but wait until xPLGirder is fully initialized
		local ded = Classes.DelayedExecutionDispatcher:New (3000, function () self:RequestAnnounce() end)
		-- set announcementcheck
		self:CreateAnnouncementTimer()
		self.AnnouncementTimer:Arm(3000 + announcementtimeout)
	end,

	ShutDown = function (self)
		-- function called upon shuttingdown this handler
		-- print ("Shutting down the xPL handler ID: " .. self.ID)
		self:DestroyAnnouncementTimer()
		for k,v in pairs(self.DevList) do
			self:DeleteRootDevice(v)
		end
		UPnP = nil 	-- destroy global variable
	end,


	AnnFragments = {},		-- private list (by their ID) of announcements received, but not yet complete ((sub-)children or parent are missing)
	IDlist = {},			-- public list (UPnP.IDlist) of all elements by their ID, elements will be added once they are complete
                            -- even if their parent might not yet be complete.
	DevList = {}, 			-- public list (UPnP.devices) of all completed root devices by their UDN. Devices will be added once a
                            -- root-device is complete
	CallID = 0,				-- a unique call ID for method calls
	ResponseQueue = {},		-- ID's of methods calls waiting for a response
	AnnouncementTimer = nil, -- timer that will be set after each received fragment, to check for completeness
	LastFragmentReceived = nil, -- date/time when the last fragment was received during an announcement

	_lock = thread.newmutex(),

	Lock = function (self)
		self._lock:lock()
	end,

	Unlock = function (self)
		self._lock:unlock()
	end,

	MessageHandler = function (self, msg, filter)
		-- protected handler to run only singular, other threads can only enter after this call completed
		self:Lock()
		local result = false
		local s,r = pcall(self._MessageHandler, self, msg, filter)
		if s then	-- success
			result = r
		else	-- failure
			-- error was returned from handler
			print("xPLHandler " .. self.ID .. " had a lua error;" .. r)
			print("while handling the following xPL message;")
			table.print(msg)
			gir.LogMessage(xPLGirder.Name, self.ID .. ' failed while processing a message, see lua console', 2)
		end
		self:Unlock()
		return result
	end,

	_MessageHandler = function (self, msg, filter)
		--[[
		The handler function below will handle the actual message. The parameters are the xPL message
		and the filter string that passed the message.

		The return value should be a boolean indicating whether the standard xPLGirder event should
		be suppressed.
			msg is a table with the following keys;
			msg.type		message type, either one of 'xpl-cmnd', 'xpl-trig', or 'xpl-stat'.
			msg.hop			message hop-count
			msg.source		source address
			msg.target		target address (or wildcard)
			msg.schema		message schema
			msg.body		contains sub-tables, each with a 'key' and a 'value' field, so to access;
							first key value  :   msg.body[1].key
							first value value:   msg.body[1].value
		]]--

		local result = false	-- default return value; do not suppress standard event

		if msg.schema == "upnp.basic" and msg.type == "xpl-trig" then
			-- updated state variable arrived
			self:UpdateStateVariable(msg)
			result = true	-- suppress standard event

		elseif msg.schema == "upnp.basic" and msg.type == "xpl-cmnd"  and msg.source == xPLGirder.Source then
            -- its a command message send by this UPnP handler, so just disable the event
            result = true   -- suppress standard event

		elseif msg.schema == "upnp.method" and msg.type == "xpl-trig" then
			-- method call results are being delivered
			local callid = GetValueByKey(msg, "callid")
			if callid ~= nil then
				if self.ResponseQueue[callid] ~= nil then
					-- its a response we're waiting for, so go store it
					self.ResponseQueue[callid] = msg
				end
			end
			result = true	-- suppress standard event

		elseif msg.schema == "upnp.announce" and msg.type == "xpl-trig" and GetValueByKey(msg, "announce") ~= "left" then
			-- new device or service or other element added
			self.LastFragmentReceived = date:now()
			self:AddAnnouncedFragment(msg)
			result = true	-- suppress standard event

		elseif msg.schema == "config.end" or msg.schema == "hbeat.end" or (msg.schema == "upnp.announce" and msg.type == "xpl-trig" and GetValueByKey(msg, "announce") == "left") then
			-- an xPL/UPnP device is leaving, check if its one of ours and delete the root devices
			result = self:RemoveDevice(msg)

		else
			-- unknown schema, do nothing
			result = false	-- do not suppress standard event
		end

		-- Determine the return value
		-- false: The standard xPLGirder event will still be created (if all other handlers also
		--        return false)
		-- true:  The standard xPLGirder event is suppressed, this should be used when the handler
		--        has created a more specific event from the xPL message than the regular xPLGirder
		--        event.
		return result
	end,

	RemoveDevice = function (self, msg)
		-- received a message that something is leaving, either UPnP or xPL device, do cleanup
		if msg.schema == "upnp.announce" and msg.type == "xpl-trig" and GetValueByKey(msg, "announce") == "left" then
			-- UPnP device is leaving
			self:RemoveUPnPDevice(msg)
			return true	-- suppress default event from xPLGirder
		elseif msg.schema == "config.end" or msg.schema == "hbeat.end" then
			-- xPLDevice is leaving
			self:RemovexPLDevice(msg)
			return false	-- do not suppress default event from xPLGirder
		end
	end,

	RemoveUPnPDevice = function (self, msg)
		-- a UPnP device is leaving, go find and delete it
		local t = GetValueByKey(msg, "id")
		t = string.Split(t, ",")
		t = t[1]					-- first item is devices main ID
		t = self.IDlist[t]			-- get device itself
		if t ~= nil then
			-- check if its a root device, and remove if so
			if t.announce == "device" and t.parent == nil then
				self:DeleteRootDevice(t)
			end
		end
	end,

	RemovexPLDevice = function (self, msg)
		-- an xPL device is leaving, check if its one of our root devices
		local del = "not nil"
		while del ~= nil do	-- use While loop because we'll be modifying the iterated table, repeat until no more found.
			del = nil
			for k,v in pairs(self.DevList) do
				if v.xpl == msg.source then
					del = v
					break
				end
			end
			if del ~= nil then
				-- so its one of ours, delete device itself
				self:DeleteRootDevice(del)
			end
		end
	end,

	DeleteRootDevice = function (self, dev)
		-- removes a specific device table from the global tables and raises Girder event
		self.DevList[dev.deviceid] = nil
		self:DeleteElement(dev)
		-- trigger event girder event for left device
		gir.TriggerEvent("UPnP device left; " .. dev.name, xPLEventDevice, dev.deviceid)
	end,

	DeleteElement = function (self, dev)
		-- removes a specific element table from the global ID list, will call itself recursive
		-- go delete the child elements
		if dev and dev.IDlist ~= nil then
			for k, v in pairs(dev.IDlist) do
				self:DeleteElement(self.IDlist[v])	 	 -- remove from completed list
				self:DeleteElement(self.AnnFragments[v]) -- remove from incomplete list
			end
		end
		-- delete element itself
        if dev and dev.ID then
            self.IDlist[dev.ID] = nil
            self.AnnFragments[dev.ID] = nil
        end
	end,

	DeleteOrphan = function (self, elem)
		-- the ID delivered is an Orphan and the requests for announcement failed, so must
		-- cleanup this one and any related elements

		-- traverse up the tree to find the highest level available
		while elem and elem.parent do
			local p = self.IDlist[elem.parent] or self.AnnFragments[elem.parent]
			if p then
				-- found a parent, move up one level
				elem = p
			else
				-- a parent was set, but not found, delete all elements with the same parent id
				-- as they are orphans too
				p = elem.parent		-- temporary store parent ID
				-- remove current element
				self:DeleteElement(elem)
				elem = nil
				-- now go and delete all other elements with this parent in the incomplete list
				for _, v in pairs(self.AnnFragments) do
					if v.parent == p then
						self:DeleteElement(v)
					end
				end
				-- now go and delete all other elements with this parent in the completed list
				for _, v in pairs(self.IDlist) do
					if v.parent == p then
						self:DeleteElement(v)
					end
				end
			end
		end
		if elem then
			-- it is a root device, because it doesn't have a parent, go delete it
			self:DeleteRootDevice(elem)
			elem = nil
		end
	end,

	RequestAnnounce = function (self)
		-- send an broadcast xpl message to announce UPnP devices
		local req = "xpl-cmnd\n{\nhop=1\nsource=%s\ntarget=*\n}\nupnp.basic\n{\ncommand=announce\n}\n"
		local msg = string.format(req, xPLGirder.Source)
		xPLGirder:SendMessage(msg)
	end,

	AddAnnouncedFragment = function (self, msg)
		local part = {}					-- will hold our received part
		-- create ID list
		local t = GetValueByKey(msg, "id")
		t = string.Split(t, ",")
		part.ID = t[1]					-- first item is our own ID
        -- check whether this ID is a duplicate
        if self.AnnFragments[part.ID] or self.IDlist[part.ID]  then
            -- ID was found in one of the tables, so it doubles. Nothing more to do, exit
            self:SetAnnouncementTimer()     -- Set timer to check for completeness
            return
        end
		-- Add remaining data to the part
		for k,v in ipairs(msg.body) do
			if v.key ~= "id" then
				part[v.key] = v.value
			end
		end
		-- split allowed values list
		if type(part.allowed) == string then
			part.allowed = string.Split(part.allowed, ',')
		end
		-- treat subdevices as devices. When using this from code, just check the
        -- absence of 'parent' key as inidicator that its a root device
		if part.announce == "subdevice" then
			part.announce = "device"
		end
		-- add methods for execution of element specific code
		if part.announce == "method" then
			self:AppendCall(part)		-- add 'execute' function to the methods table
		elseif part.announce == "variable" or part.announce == "service" or part.announce == "device" then
			self:AppendPoll(part)		-- add 'poll' function to the variable/service/device tables
		end
		-- create the ID list of the child elements
		part.IDlist = {}				-- list with all our children ids
		part.WaitingFor = {}			-- list with ids waiting for, to be complete
		if part.announce == "method" then
			part.order = {}				-- table with the argument order for the method
		end
		for i, v in ipairs(t) do
			if v ~= part.ID then		-- if its not our own ID, then add it
				part.IDlist[v] = v
				part.WaitingFor[v] = v
				if part.announce == "method" then
					part.order[i-1] = v		-- use n-1 because the first is always the skipped own ID
				end
			end
		end

		-- Check if any of my children are around already
		if not table.IsEmpty(part.WaitingFor) then
			-- I do have children, go check each one in the COMPLETED list
			local done ={}		-- done list, will be deleted at end, to prevent messing with table while iterating
			for k,v in pairs(part.WaitingFor) do
				local child = self.IDlist[k]
				if child ~= nil then
					-- found one !
					if child.announce == "device" then
						part.devices = part.devices or {}
						part.devices[CleanKey(child.deviceid)] = child
					elseif child.announce == "service" then
						part.services = part.services or {}
						part.services[CleanKey(child.service)] = child
					elseif child.announce == "method" then
						part.methods = part.methods or {}
						part.methods[child.name] = child
					elseif child.announce == "argument" then
						part.arguments = part.arguments or {}
						part.arguments[child.name] = child
					elseif child.announce == "variable" then
						part.variables = part.variables or {}
						part.variables[child.name] = child
					end
					-- add to list to be removed because they are done
					done[child.ID] = child.ID
				end
			end
			-- remove 'done' list
			for k,v in pairs(done) do
				part.WaitingFor[k] = nil
			end
		end

		-- Check if I'm complete...
		if table.IsEmpty(part.WaitingFor) then
			-- Part is complete store in completed list
			part.WaitingFor = nil
			self.IDlist[part.ID] = part
			self:PartComplete(part.ID)
		else
			-- store received fragment
			self.AnnFragments[part.ID] = part
		end

		-- Set timer to check for completeness
		self:SetAnnouncementTimer()
	end,

	PartComplete = function (self, pID)
		-- the mentioned ID is complete and in the completed elements IDlist, attach it to parent
		-- and check parent completenss
		local p = self.IDlist[pID]

		if p.announce == "device" and p.parent == nil then
			-- its a completed root-device, just copy it to the device list
			self.DevList[p.deviceid] = p
			gir.TriggerEvent("UPnP device arrived; " .. p.name, xPLEventDevice, p.deviceid)
			-- announcement complete, request the devices variable values, but delayed to prevent flooding the xPL network
			local ded = Classes.DelayedExecutionDispatcher:New (3000, function () self:RequestVariableValues(pID) end)
		else
			if p.announce == "service" then
				-- whenever a service completes, update all methods to attach the related statevariable table
				-- to the 'variable' key instead of the received ID
				if p.methods ~= nil then
					for methodname, methodtable in pairs(p.methods) do
						if methodtable.arguments ~= nil then
							for argname, argtable in pairs(methodtable.arguments) do
								if type(argtable.variable) ~= "table" then
									argtable.variable = self.IDlist[argtable.variable]
								end
							end
						end
					end
				end
			end
			-- find parent and attach it
			local pt = self.AnnFragments[p.parent]
			if pt == nil then
				-- parent not found, so do nothing, have to wait for it to arrive
			else
				-- attach to parent
				if p.announce == "device" then
					pt.devices = pt.devices or {}
					pt.devices[CleanKey(p.deviceid)] = p
				elseif p.announce == "service" then
					pt.services = pt.services or {}
					pt.services[CleanKey(p.service)] = p
				elseif p.announce == "method" then
					pt.methods = pt.methods or {}
					pt.methods[p.name] = p
				elseif p.announce == "argument" then
					pt.arguments = pt.arguments or {}
					pt.arguments[p.name] = p
				elseif p.announce == "variable" then
					pt.variables = pt.variables or {}
					pt.variables[p.name] = p
				end
				-- remove from parents waiting for list
				pt.WaitingFor[p.ID] = nil
				-- check parent completeness
				if table.IsEmpty(pt.WaitingFor) then
					-- move to completed list and handle complete item (recursive function call)
					pt.WaitingFor = nil
					self.AnnFragments[p.parent] = nil
					self.IDlist[pt.ID] = pt
					self:PartComplete(pt.ID)
				end
			end
		end
	end,

	UpdateStateVariable = function (self, msg)
		for i,kvp in ipairs(msg.body) do
			local svar = self.IDlist[kvp.key]
            local k = kvp.key
            local v = kvp.value
            -- check if value was chopped, and restore if necesary
            if v == "<<chopped_it>>" then
                -- it was chopped, so we must reconstruct
                local c = 1
                local kv
                v = ""
                repeat
                    kv = GetValueByKey(msg, k .. "-" .. c)
                    if kv then
                        v = v .. kv
                    end
                    c = c + 1
                until kv == nil
            end

			if svar ~= nil then
				-- found a statevariable
				local old = svar.value
				svar.value = v
				local pservice = self.IDlist[svar.parent]		-- gets the parent service of the statevariable
				if pservice ~= nil then
					local pdevice = self.IDlist[pservice.parent]	-- gets the parent device of the service
					if pdevice ~= nil then
						local devname = pdevice.name or "(unannounced device)"					-- gets the actual device name
						gir.TriggerEvent("UPnP value update " .. devname .. ":" .. svar.name, xPLEventDevice, svar.ID, v, old)
					else
						-- device not found, assume announcement incomplete, no girder event
					end
				else
					-- service not found, assume announcement incomplete, no girder event
				end
            else
                -- no variable found, not announced yet, so do nothing
			end
		end
	end,


	CallMethod = function (self, method, ...)
		-- Calls the provided UPnP method using the extra arguments
		-- check method
		if method == nil then
			error("No method provided, first argument must be method table", 2)
		elseif method.announce == nil then
			error("Table provided is not a UPnP element", 2)
		elseif method.announce ~= "method" then
			error("UPnP element provided is not a Method", 2)
		end

		-- construct xPL message
		local header = "xpl-cmnd\n{\nhop=1\nsource=%s\ntarget=%s\n}\nupnp.method\n{\ncommand=methodcall\nmethod=%s\ncallid=%s\n"
		local footer = "}\n"
		local body = ""
		for i,v in ipairs(method.order) do
			local t = type(arg[i])
			local value = arg[i]
			-- first convert value to string type
			if t == "string" then
				-- no need to do anything
			elseif t == "number" then
				value = value .. ""
			elseif t == "boolean" then
				if value then
					value = "True"
				else
					value = "False"
				end
			elseif t == "nil" then
				value = ""
			else
				-- function, userdata, thread, and table
				error("Cannot handle type '" .. t .. "' as input parameter for a UPnP methodcall.")
			end
			body = body .. string.format("%s=%s\n", v, value)
		end
		local msg = string.format(header .. body .. footer, xPLGirder.Source, method.xpl, method.ID, self.CallID)
		self.CallID = self.CallID + 1					-- increase unique ID by 1
		xPLGirder:SendMessage(msg)
		return self:WaitForResponse(method.ID, self.CallID - 1)
	end,

	WaitForResponse = function (self, MethodID, CallID)
		-- waits for a response on a method call, by ID of 'CallID' and returns the returned UPnP parameters
		CallID = CallID .. "" 	-- force to a string
		self:Lock()
		self.ResponseQueue[CallID] = CallID		-- post ID we're waiting for
		self:Unlock()
		local done = false
		local msg
		local waituntil = date:now()
		waituntil.Second = waituntil.Second + 20	-- timeout after 20 seconds
		while not done do
			win.Sleep(100)
			self:Lock()
			if type(self.ResponseQueue[CallID]) == "table" then
				-- type changed to a table, so it now contains the xPL message with the response
				msg = self.ResponseQueue[CallID]
				self.ResponseQueue[CallID] = nil
				done = true
			elseif waituntil < date:now() then
				-- waiting timed out, so exit
				self.ResponseQueue[CallID] = nil	-- cleanup
				done = true
			end
			self:Unlock()
		end
		-- we're done
		if msg == nil then
			-- timedout
			return false, "No response received (time out)"
		else
			-- deal with the response
			local success = (string.lower(GetValueByKey(msg, "success") or "") == "true")
			if not success then
				-- failed call, report error
				return false, GetValueByKey(msg, "error") or "No error message was provided"
			else
				-- successfull call, dissect response
				local response = {}
				local i = 1
				-- lookup the method it was a response to
				local method = self.IDlist[MethodID]
				if method == nil then
					-- something is wrong
					return false, "Could not locate method for this reponse message, UPnP device left?"
				end
				--response[i] = GetValueByKey(msg, "retval") or ""	-- 2nd argument is return value
				--i = i + 1
				-- now add all OUT parameters
				for n,argID in ipairs(method.order) do	-- loop through the arguments in the correct order as specified
					if self.IDlist[argID].direction == "out" then
						-- got an out-going parameter, get value and add it
						response[i] = GetValueByKey(msg, argID) or ""
                        if response[i] == "<<chopped_it>>" then
                            -- it was chopped, so we must reconstruct
                            local c = 1
                            local kv
                            response[i] = ""
                            repeat
                                kv = GetValueByKey(msg, argID .. "-" .. c)
                                if kv then
                                    response[i] = response[i] .. kv
                                end
                                c = c + 1
                            until kv == nil
                        end
						i = i + 1
					end
				end
				-- response table completed, now return the values
				return true, unpack(response)
			end
		end
	end,

	AppendCall = function (self, method)
		-- takes a 'method' table and appends an 'execute' function
		method.execute = function (method, ...) return self:CallMethod(method, unpack(arg)) end
		return method
	end,

	RequestVariableValues = function (self, pID)
		-- Request variable values for this device
		if not table.IsEmpty(self.AnnFragments) then
			-- Announcement fragment list is not empty, so probably we're still in the announcement phase with lots
			-- of traffic, so delay the variable update request
			local ded = Classes.DelayedExecutionDispatcher:New (3000, function () self:RequestVariableValues(pID) end)
		else
			pID = (pID or "") .. ""		-- convert to string
			if pID == "" then
				error("No ID provided for the element to poll for its variables.")
			end
			local dev = self.IDlist[pID]
			if dev.announce ~= "device" and dev.announce ~= "service" and dev.announce ~= "variable" then
				error("Can only request values for types device, service, and variable. Not for type " .. dev.announce)
			end
			local req = "xpl-cmnd\n{\nhop=1\nsource=%s\ntarget=%s\n}\nupnp.basic\n{\ncommand=requestvalue\nid=%s\n}\n"
			local msg = string.format(req, xPLGirder.Source, dev.xpl, pID)
			xPLGirder:SendMessage(msg)
		end
	end,

	AppendPoll = function(self, element)
		-- append a 'poll' method to the element table
		local id = element.ID
		element.poll = function () self:RequestVariableValues(id) end
	end,

	-- Timer elements to verify completeness of announcement, and request missing elements if necessary
	CheckAnnouncement = function(self)
		-- check whether all announced parts have been completed to complete root-devices
		-- request missing parts if necessary

		local request = {}  -- List with IDs to request

        -- send xplmessage to request single id
        local requestid = function(childid)
            local req = "xpl-cmnd\n{\nhop=1\nsource=%s\ntarget=*\n}\nupnp.basic\n{\ncommand=announce\nid=%s\n}\n"
            local msg = string.format(req, xPLGirder.Source, childid)
            xPLGirder:SendMessage(msg)
        end

		-- setup local recursive function to check 1 individual part recursively
		local checkpart = nil
		checkpart = function(self, id)
			local part = self.AnnFragments[id]
            -- check parent availability
            if part.parent then
                if self.AnnFragments[part.parent] then
                    -- parent is available (but incomplete), do nothing
                else
                    -- no parent available, must request it then, add parent to the list
                    request[part.parent] = part.parent
                    -- requesting a parent will also automatically announce all children, so no need
                    -- to go check them anymore, just return here.
                    return
                end
            end
            -- check children
			if not table.IsEmpty(part.WaitingFor) then
				for childid, _ in pairs(part.WaitingFor) do
					if self.AnnFragments[childid] then
						-- this child has been announced, but apparently is also incomplete still -> recurse!
						checkpart(self,childid)
					else
						-- this child is unknown to us still, so go add to the request list
						request[childid] = childid
					end
				end
			end
		end

		self:Lock()
		if not table.IsEmpty(self.AnnFragments) then
			-- so we're not complete, go check the announced fragments list

			-- check whether we received anything lately, if not, we've got orphans
			local dl = date:now()
			dl.Second = dl.Second - (3 * announcementtimeout/1000)
			if self.LastFragmentReceived < dl then
				-- nothing was received for 3 x timeout seconds, assume fragment to be orphaned
                while not table.IsEmpty(self.AnnFragments) do
                    for id, part in pairs(self.AnnFragments) do
                        self:DeleteOrphan(part)
                        break   -- exit loop because we're messing with the table while iterating it
                    end
                end
                gir.LogMessage(xPLGirder.Name, self.ID .. ' announcement request time-out; removed orphaned elements', 1)
			end

            -- remove any duplicates
			for id, part in pairs(self.AnnFragments) do
				if self.IDlist[id] then
					-- its in both lists, should not occur, but can happen if parts are announced twice
					-- play safe and keep the complete one, delete the new announced part to prevent an
					-- endless loop of re-requesting parts
					self.AnnFragments[id] = nil
                end
			end
            -- go check all remaining parts for completeness
			for id, part in pairs(self.AnnFragments) do
                checkpart(self, id)
            end
            -- do any requests we have to do
            local count = 0
            for id, _ in pairs(request) do
                requestid(id)       -- send xpl message with request
                count = count + 1
            end
            -- signal warning
            if count ~= 0 then
                gir.LogMessage(xPLGirder.Name, self.ID .. ' bad announcement, now requesting ' .. tostring(count) ..  ' elements still missing', 1)
            end
			-- set timer again, if still not complete
			if not table.IsEmpty(self.AnnFragments) then
				self:SetAnnouncementTimer()
			end
		end
		self:Unlock()
	end,

	CreateAnnouncementTimer = function(self)
		-- creates the announcement timer at component startup, will NOT arm the timer
		self:DestroyAnnouncementTimer()
		self.AnnouncementTimer = gir.CreateTimer(nil, function() self:CheckAnnouncement() end, nil, false)
	end,

	SetAnnouncementTimer = function(self)
		-- sets the timer to expire in x seconds, and hence go check for announcement completeness
		if self.AnnouncementTimer then
            self.AnnouncementTimer:Cancel()
			self.AnnouncementTimer:Arm(announcementtimeout)
		end
	end,

	DestroyAnnouncementTimer = function(self)
		-- destroys the announcement timer at component stop
		if self.AnnouncementTimer then
			self.AnnouncementTimer:Destroy()
			self.AnnouncementTimer = nil
		end
	end,

}



-- finally deliver the handler to the xPLGirder component
return myNewHandler
