
require 'Classes.DelayedExecutionDispatcher'

require 'thread'

require 'date'

local announcementtimeout = 3000       -- seconds after which to re-request missing parts

local el	-- trick luadoc
-------------------------------------------------------------------------------------------
-- Girder events generated by the UPnP handler. All events will have "xPL" as the
-- event source.
-- @name UPnP events
-- @class table
-- @field arriving Whenever a new UPnP device arrives the following event is raised. Note that
-- 3 seconds after the event automatically a variable update request will be sent.<ul>
-- <li><code>eventstring</code>: "UPnP device arrived; &ltdevice name&gt"</li>
-- <li><code>pld1</code>: device ID assigned to the device</li>
-- <li><code>pld2</code>: nil</li>
-- <li><code>pld3</code>: nil</li>
-- <li><code>pld3</code>: nil</li>
-- </ul>
-- @field leaving Whenever a UPnP device leaves the following event is raised. Note that
-- the device has already been removed from the list when the event is raised.<ul>
-- <li><code>eventstring</code>: "UPnP device left; &ltdevice name&gt"</li>
-- <li><code>pld1</code>: device ID assigned to the device</li>
-- <li><code>pld2</code>: nil</li>
-- <li><code>pld3</code>: nil</li>
-- <li><code>pld3</code>: nil</li>
-- </ul>
-- @field updates Whenever an update of a UPnP variable arrives (automatically for evented variables
-- or upon request for non-evented variables) the following event is raised.<ul>
-- <li><code>eventstring</code>: "UPnP value update &ltdevice name&gt:&ltvariable name&gt"</li>
-- <li><code>pld1</code>: ID of the variable that changed</li>
-- <li><code>pld2</code>: new value of the variable</li>
-- <li><code>pld3</code>: old value of the variable</li>
-- <li><code>pld3</code>: nil</li>
-- </ul>
el = {}
el = nil


local Events = table.makeset ( {
	'DeviceArrived',
    'DeviceLeft',
    'DeviceVariable',
} )

local typetable = {         -- everything not in the table is considered string
    boolean = "boolean",
    ui1 = "number",
    ui2 = "number",
    ui4 = "number",
    i1 = "number",
    i2 = "number",
    i4 = "number",
    int = "number",
    r4 = "number",
    r8 = "number",
    number = "number",
    ['fixed.14.4'] = "number",
    float = "number",
    date = "date",
    dateTime = "date",
    ['dateTime.tz'] = "date",
    time = "date",
    ['time.tz'] = "date",
}


local Super = require 'Components.xPL.Handlers.Base'

local myNewHandler = Super:New ( {

    ID = 13101, -- component id

	Name = "UPnP",		-- enter a unique string to identify this handler

    Description = 'UPnP from xPL interface',

    ConfigFile = 'UPnP',

    Version = '0.0.1',

	AnnFragments = {},		-- private list (by their ID) of announcements received, but not yet complete ((sub-)children or parent are missing)

	IDlist = {},			-- public list (UPnP.IDlist) of all elements by their ID, elements will be added once they are complete
                            -- even if their parent might not yet be complete.
	DevList = {}, 			-- public list (UPnP.devices) of all completed root devices by their UDN. Devices will be added once a
                            -- root-device is complete
	CallID = 0,				-- a unique call ID for method calls

	ResponseQueue = {},		-- ID's of methods calls waiting for a response

	AnnouncementTimer = nil, -- timer that will be set after each received fragment, to check for completeness

	LastFragmentReceived = nil, -- date/time when the last fragment was received during an announcement

	Filters = {
		"*.*.*.*.upnp.basic",
		"*.*.*.*.upnp.announce",
		"*.*.*.*.upnp.method",
		"*.*.*.*.hbeat.end",
		"*.*.*.*.config.end",
	},

    Initialize = function (self)
         self:AddEvents (Events)

        return Super.Initialize (self)
    end,

    Enable = function (self)
		-- define global tables
		UPnP = {
			IDlist = self.IDlist,
			devices = self.DevList,
			-----------------------------------------------------------------------------------------
			-- Calls a UPnP method. The call is synchroneous and will (wait for) and return the results
			-- (eventhough the communications are asynchroneous, both xPL and UPnP). There is a fixed
			-- timeout of 20 seconds if the UPnP device does not respond.<br/>There are 2 ways to call
			-- a method; 1) directly on the method table, 2) indirectly using a generic call. See the
			-- example below for the difference, the results will be identical.
			-- @name UPnP.CallMethod
		    -- @param methodid The ID of the method to execute
			-- @param ... parameters for the method, all parameters MUST be provided for the call to succeed
		    -- @return success (boolean) <code>true</code> if the call was succesfull, if it failed, the
			-- second return value will contain the error.
			-- @return additional return values are all the OUT arguments of the method
			-- @usage# -- The ID's below are fixed, and will not change over time (but might after firmware update)
			-- local RecivaUUID = "c29e7602-328f-444d-911c-7cdc8bc74768"
			-- local RadioServiceID = "urn_reciva-com_serviceId_RecivaRadio"
			-- -- Get method "GetPlaybackDetails" from the device/service
			-- local m = UPnP.devices[RecivaUUID].services[RadioServiceID].methods["GetPlaybackDetails"]
			-- &nbsp
			-- -- method1: call directly on method table (must provide each argument, even though not used!)
			-- local success, result = m:execute("", "")
			-- &nbsp
			-- -- method2: call indirectly using generic call (must provide each argument, even though not used!)
			-- local success, result = UPnP:CallMethod(m.ID, "", "")	-- m.ID additional argument needed here
			CallMethod = function (self, methodid, ...)
					methodid = (methodid or "") .. ""	-- convert to string
					local method = self.IDlist[methodid]
					if method == nil then
						error("No (valid) method provided, first argument must be method id, remaining arguments the parameters to the method.", 2)
					end
					return method:execute(unpack(arg))
				end,
			-----------------------------------------------------------------------------------------
			-- Calls a UPnP method. The call is asynchroneous and will return the results through a
            -- callback function. There is a fixed
			-- timeout of 20 seconds if the UPnP device does not respond.<br/>There are 2 ways to call
			-- a method; 1) directly on the method table, 2) indirectly using a generic call. See the
			-- example below for the difference, the results will be identical.
            -- =================================
            -- MUST BE UPDATED !!!
            -- =================================
			-- @name UPnP.CallMethodAsync
		    -- @param methodid The ID of the method to execute
            -- @param callback The callback function to call with the results of the method call
			-- @param ... parameters for the method, all parameters MUST be provided for the call to succeed
		    -- @return success (boolean) <code>true</code> if the call was succesfull, if it failed, the
			-- second return value will contain the error.
			-- @return additional return values are all the OUT arguments of the method
			-- @usage# -- The ID's below are fixed, and will not change over time (but might after firmware update)
			-- local RecivaUUID = "c29e7602-328f-444d-911c-7cdc8bc74768"
			-- local RadioServiceID = "urn_reciva-com_serviceId_RecivaRadio"
			-- -- Get method "GetPlaybackDetails" from the device/service
			-- local m = UPnP.devices[RecivaUUID].services[RadioServiceID].methods["GetPlaybackDetails"]
			-- &nbsp
			-- -- method1: call directly on method table (must provide each argument, even though not used!)
			-- local success, result = m:execute("", "")
			-- &nbsp
			-- -- method2: call indirectly using generic call (must provide each argument, even though not used!)
			-- local success, result = UPnP:CallMethod(m.ID, "", "")	-- m.ID additional argument needed here
			CallMethodAsync = function (self, methodid, callback, ...)
					methodid = (methodid or "") .. ""	-- convert to string
                    assert(callback == nil or type(callback) == "function", "Bad callback provided, expected nil or function, got " .. type(callback))
					local method = self.IDlist[methodid]
					if method == nil then
						error("No (valid) method provided, first argument must be method id, remaining arguments the parameters to the method.", 2)
					end
					return method:executeasync(callback, unpack(arg))
				end,
			-----------------------------------------------------------------------------------------
			-- Requests current value of a device, service or variable. In case of a variable only
			-- a single value will be requested, in case of a device or service the values off all
			-- underlying variables (within nested devices/services) will be requested. The request
			-- will be executed asynchroneously, the updates will come in as regular value updates.
			-- <br/><strong>Important note</strong>: UPnP does not provide a way to request variable
			-- values. The UPnP-2-xPL gateway provides a rudimentary workaround, which quite often
			-- won't work. See the gateway documentation for details on what to expect.
			-- <br/>There are 2 ways to request a value;
			-- 1) directly on the service/device/variable table, 2) indirectly using a generic call. See the
			-- example below for the difference, the results will be identical.
			-- @name UPnP.PollValue
			-- @param id The ID of the device, service or variable for which the update is requested.
			-- @return Nothing
			-- @usage# -- The ID's below are fixed, and will not change over time (but might after firmware update)
			-- local RecivaUUID = "c29e7602-328f-444d-911c-7cdc8bc74768"
			-- local RadioServiceID = "urn_reciva-com_serviceId_RecivaRadio"
			-- -- Get the service from the device table, the request on a service will return all variables within it
			-- local s = UPnP.devices[RecivaUUID].services[RadioServiceID]
			-- &nbsp
			-- -- method1: call directly on service/device/variable table
			-- s:poll()
			-- &nbsp
			-- -- method2: call indirectly using generic call
			-- UPnP:PollValue(s.ID)	-- s.ID additional argument needed here
			PollValue = function (self, id)
					id = (id or "") .. "" -- convert to string
					if id == "" then
						error ("No ID provided for the element whose values to poll")
					end
					local elem = self.IDlist[id]
					if elem == nil then
						error ("ID '" .. id .. "' is not valid for polling variables values")
					end
					if type(elem.poll) ~= "function" then
						error ("ID '" .. id .. "' is not valid for polling variables values")
					end
					elem:poll()
				end,
		}

		-- send announce request, but wait until xPL is fully initialized
		local ded = Classes.DelayedExecutionDispatcher:New (3000, function () self:RequestAnnounce() end)

		-- set announcementcheck
		self:CreateAnnouncementTimer()
		self.AnnouncementTimer:Arm(3000 + announcementtimeout)

        return Super.Enable (self)
	end,


    Disable = function (self)
		self:DestroyAnnouncementTimer()

		for k,v in pairs(self.DevList) do
			self:DeleteRootDevice(v)
		end

		UPnP = nil 	-- destroy global variable

        local b = Super.Disable (self)
        return b
    end,


	_MessageHandler = function (self, msg, filter)
		--[[
		The handler function below will handle the actual message. The parameters are the xPL message
		and the filter string that passed the message.

		The return value should be a boolean indicating whether the standard xPL event should
		be suppressed.
			msg is a table with the following keys;
			msg.type		message type, either one of 'xpl-cmnd', 'xpl-trig', or 'xpl-stat'.
			msg.hop			message hop-count
			msg.source		source address
			msg.target		target address (or wildcard)
			msg.schema		message schema
			msg.body		contains sub-tables, each with a 'key' and a 'value' field, so to access;
							first key value  :   msg.body[1].key
							first value value:   msg.body[1].value
		]]--

		local result = false	-- default return value; do not suppress standard event

		if msg.schema == "upnp.basic" and msg.type == "xpl-trig" then
			-- updated state variable arrived
			self:UpdateStateVariable(msg)
			result = true	-- suppress standard event

		elseif msg.schema == "upnp.basic" and msg.type == "xpl-cmnd"  and msg.source == self.xPL.Source then
            -- its a command message send by this UPnP handler, so just disable the event
            result = true   -- suppress standard event

		elseif msg.schema == "upnp.method" and msg.type == "xpl-trig" then
			-- method call results are being delivered
            self:HandleMethodResult(msg)
			result = true	-- suppress standard event

		elseif msg.schema == "upnp.announce" and msg.type == "xpl-trig" and self:GetMessageValueByKey(msg, "announce") ~= "left" then
			-- new device or service or other element added
			self.LastFragmentReceived = date:now()
			self:AddAnnouncedFragment(msg)
			result = true	-- suppress standard event

		elseif msg.schema == "config.end" or msg.schema == "hbeat.end" or (msg.schema == "upnp.announce" and msg.type == "xpl-trig" and self:GetMessageValueByKey(msg, "announce") == "left") then
			-- an xPL/UPnP device is leaving, check if its one of ours and delete the root devices
			result = self:RemoveDevice(msg)

		else
			-- unknown schema, do nothing
			result = false	-- do not suppress standard event
		end

		-- Determine the return value
		-- false: The standard xPL event will still be created (if all other handlers also
		--        return false)
		-- true:  The standard xPL event is suppressed, this should be used when the handler
		--        has created a more specific event from the xPL message than the regular xPL
		--        event.
		return result
	end,


	RemoveDevice = function (self, msg)
		-- received a message that something is leaving, either UPnP or xPL device, do cleanup
		if msg.schema == "upnp.announce" and msg.type == "xpl-trig" and self:GetMessageValueByKey(msg, "announce") == "left" then
			-- UPnP device is leaving
			self:RemoveUPnPDevice(msg)
			return true	-- suppress default event from xPL
		elseif msg.schema == "config.end" or msg.schema == "hbeat.end" then
			-- xPLDevice is leaving
			self:RemovexPLDevice(msg)
			return false	-- do not suppress default event from xPL
		end
	end,


	RemoveUPnPDevice = function (self, msg)
		-- a UPnP device is leaving, go find and delete it
		local t = self:GetMessageValueByKey(msg, "id")
		t = string.Split(t, ",")
		t = t[1]					-- first item is devices main ID
		t = self.IDlist[t]			-- get device itself
		if t ~= nil then
			-- check if its a root device, and remove if so
			if t.announce == "device" and t.parent == nil then
				self:DeleteRootDevice(t)
			end
		end
	end,


    RemovexPLDevice = function (self, msg)
		-- an xPL device is leaving, check if its one of our root devices
		local del = "not nil"
		while del ~= nil do	-- use While loop because we'll be modifying the iterated table, repeat until no more found.
			del = nil
			for k,v in pairs(self.DevList) do
				if v.xpl == msg.source then
					del = v
					break
				end
			end
			if del ~= nil then
				-- so its one of ours, delete device itself
				self:DeleteRootDevice(del)
			end
		end
	end,


	DeleteRootDevice = function (self, dev)
		-- removes a specific device table from the global tables and raises Girder event
		self.DevList[dev.deviceid] = nil
		self:DeleteElement(dev)
		-- trigger event girder event for left device
        self:Event (self.Events.DeviceLeft,dev)
		gir.TriggerEvent("UPnP device left; " .. dev.name, self.xPL.ID, dev.deviceid)
	end,


	DeleteElement = function (self, dev)
		-- removes a specific element table from the global ID list, will call itself recursive
		-- go delete the child elements
		if dev and dev.IDlist ~= nil then
			for k, v in pairs(dev.IDlist) do
				self:DeleteElement(self.IDlist[v])	 	 -- remove from completed list
				self:DeleteElement(self.AnnFragments[v]) -- remove from incomplete list
			end
		end
		-- delete element itself
        if dev and dev.ID then
            self.IDlist[dev.ID] = nil
            self.AnnFragments[dev.ID] = nil
        end
	end,


	DeleteOrphan = function (self, elem)
		-- the ID delivered is an Orphan and the requests for announcement failed, so must
		-- cleanup this one and any related elements

		-- traverse up the tree to find the highest level available
		while elem and elem.parent do
			local p = self.IDlist[elem.parent] or self.AnnFragments[elem.parent]
			if p then
				-- found a parent, move up one level
				elem = p
			else
				-- a parent was set, but not found, delete all elements with the same parent id
				-- as they are orphans too
				p = elem.parent		-- temporary store parent ID
				-- remove current element
				self:DeleteElement(elem)
				elem = nil
				-- now go and delete all other elements with this parent in the incomplete list
				for _, v in pairs(self.AnnFragments) do
					if v.parent == p then
						self:DeleteElement(v)
					end
				end
				-- now go and delete all other elements with this parent in the completed list
				for _, v in pairs(self.IDlist) do
					if v.parent == p then
						self:DeleteElement(v)
					end
				end
			end
		end
		if elem then
			-- it is a root device, because it doesn't have a parent, go delete it
			self:DeleteRootDevice(elem)
			elem = nil
		end
	end,


	RequestAnnounce = function (self)
		-- send an broadcast xpl message to announce UPnP devices
		local req = "xpl-cmnd\n{\nhop=1\nsource=%s\ntarget=*\n}\nupnp.basic\n{\ncommand=announce\n}\n"
		local msg = string.format(req, self.xPL.Source)
		self.xPL:SendMessage(msg)
	end,


	AddAnnouncedFragment = function (self, msg)
		local part = {}					-- will hold our received part
		-- create ID list
		local t = self:GetMessageValueByKey(msg, "id")
		t = string.Split(t, ",")
		part.ID = t[1]					-- first item is our own ID
        -- check whether this ID is a duplicate
        if self.AnnFragments[part.ID] or self.IDlist[part.ID]  then
            -- ID was found in one of the tables, so it doubles. Nothing more to do, exit
            self:SetAnnouncementTimer()     -- Set timer to check for completeness
            return
        end
		-- Add remaining data to the part
		for k,v in ipairs(msg.body) do
			if v.key ~= "id" then
				part[v.key] = v.value
			end
		end
		-- split allowed values list
		if type(part.allowed) == string then
			part.allowed = string.Split(part.allowed, ',')
		end
		-- treat subdevices as devices. When using this from code, just check the
        -- absence of 'parent' key as inidicator that its a root device
		if part.announce == "subdevice" then
			part.announce = "device"
		end
		-- add methods for execution of element specific code
		if part.announce == "method" then
			self:AppendCall(part)		-- add 'execute' function to the methods table
		elseif part.announce == "variable" or part.announce == "service" or part.announce == "device" then
			self:AppendPoll(part)		-- add 'poll' function to the variable/service/device tables
		end
		-- create the ID list of the child elements
		part.IDlist = {}				-- list with all our children ids
		part.WaitingFor = {}			-- list with ids waiting for, to be complete
		if part.announce == "method" then
			part.order = {}				-- table with the argument order for the method
		end
		for i, v in ipairs(t) do
			if v ~= part.ID then		-- if its not our own ID, then add it
				part.IDlist[v] = v
				part.WaitingFor[v] = v
				if part.announce == "method" then
					part.order[i-1] = v		-- use n-1 because the first is always the skipped own ID
				end
			end
		end

		-- Check if any of my children are around already
		if not table.IsEmpty(part.WaitingFor) then
			-- I do have children, go check each one in the COMPLETED list
			local done ={}		-- done list, will be deleted at end, to prevent messing with table while iterating
			for k,v in pairs(part.WaitingFor) do
				local child = self.IDlist[k]
				if child ~= nil then
					-- found one !
					if child.announce == "device" then
						part.devices = part.devices or {}
						part.devices[self:CleanKey(child.deviceid)] = child
					elseif child.announce == "service" then
						part.services = part.services or {}
						part.services[self:CleanKey(child.service)] = child
					elseif child.announce == "method" then
						part.methods = part.methods or {}
						part.methods[child.name] = child
					elseif child.announce == "argument" then
						part.arguments = part.arguments or {}
						part.arguments[child.name] = child
					elseif child.announce == "variable" then
						part.variables = part.variables or {}
						part.variables[child.name] = child
					end
					-- add to list to be removed because they are done
					done[child.ID] = child.ID
				end
			end
			-- remove 'done' list
			for k,v in pairs(done) do
				part.WaitingFor[k] = nil
			end
		end

		-- Check if I'm complete...
		if table.IsEmpty(part.WaitingFor) then
			-- Part is complete store in completed list
			part.WaitingFor = nil
			self.IDlist[part.ID] = part
			self:PartComplete(part.ID)
		else
			-- store received fragment
			self.AnnFragments[part.ID] = part
		end

		-- Set timer to check for completeness
		self:SetAnnouncementTimer()
	end,


	PartComplete = function (self, pID)
		-- the mentioned ID is complete and in the completed elements IDlist, attach it to parent
		-- and check parent completenss
		local p = self.IDlist[pID]

		if p.announce == "device" and p.parent == nil then
			-- its a completed root-device, just copy it to the device list
			self.DevList[p.deviceid] = p
			gir.TriggerEvent("UPnP device arrived; " .. p.name, self.xPL.ID, p.deviceid)
			-- announcement complete, request the devices variable values, but delayed to prevent flooding the xPL network
			local ded = Classes.DelayedExecutionDispatcher:New (3000, function () self:RequestVariableValues(pID) end)

            self:ProcessNewUPnPDevice (p)
		else
			if p.announce == "service" then
				-- whenever a service completes, update all methods to attach the related statevariable table
				-- to the 'variable' key instead of the received ID
				if p.methods ~= nil then
					for methodname, methodtable in pairs(p.methods) do
						if methodtable.arguments ~= nil then
							for argname, argtable in pairs(methodtable.arguments) do
								if type(argtable.variable) ~= "table" then
									argtable.variable = self.IDlist[argtable.variable]
								end
							end
						end
					end
				end
			end
			-- find parent and attach it
			local pt = self.AnnFragments[p.parent]
			if pt == nil then
				-- parent not found, so do nothing, have to wait for it to arrive
			else
				-- attach to parent
				if p.announce == "device" then
					pt.devices = pt.devices or {}
					pt.devices[self:CleanKey(p.deviceid)] = p
				elseif p.announce == "service" then
					pt.services = pt.services or {}
					pt.services[self:CleanKey(p.service)] = p
                    self:ProcessNewUPnPService (pt,p)
				elseif p.announce == "method" then
					pt.methods = pt.methods or {}
					pt.methods[p.name] = p
				elseif p.announce == "argument" then
					pt.arguments = pt.arguments or {}
					pt.arguments[p.name] = p
				elseif p.announce == "variable" then
					pt.variables = pt.variables or {}
					pt.variables[p.name] = p
				end
				-- remove from parents waiting for list
				pt.WaitingFor[p.ID] = nil
				-- check parent completeness
				if table.IsEmpty(pt.WaitingFor) then
					-- move to completed list and handle complete item (recursive function call)
					pt.WaitingFor = nil
					self.AnnFragments[p.parent] = nil
					self.IDlist[pt.ID] = pt
					self:PartComplete(pt.ID)
				end
			end
		end
	end,

    ConvertToType = function (self, value, statevar)
        -- convert the value to the Lua type indicated by statevariable
        -- see the typetable for conversion types
        -- value: the string value received
        -- statevar: the state variable containing the type to return
        -- returns: the value in the converted format
        if value and type(statevar == "table") and statevar.type then
            local vt = typetable[string.lower(statevar.type)]
            if vt == "boolean" then
                -- its a bool, go convert
                value = string.lower(value)
                value = ( value == "true" or value == "1" or value == "yes" )
            elseif vt == "number" then
                -- its a number
                value = tonumber(value)
            else
                -- stick to string, do nothing
            end
        end
        return value
    end,

	UpdateStateVariable = function (self, msg)
		for i,kvp in ipairs(msg.body) do
			local svar = self.IDlist[kvp.key]
            local k = kvp.key
            local v = kvp.value
            -- check if value was chopped, and restore if necesary
            if v == "<<chopped_it>>" then
                -- it was chopped, so we must reconstruct
                local c = 1
                local kv
                v = ""
                repeat
                    kv = self:GetMessageValueByKey(msg, k .. "-" .. c)
                    if kv then
                        v = v .. kv
                    end
                    c = c + 1
                until kv == nil
            end

			if svar ~= nil then
				-- found a statevariable
				local old = svar.value
                -- convert type of variable
                svar.value = self:ConvertToType(v, svar)
				local pservice = self.IDlist[svar.parent]		-- gets the parent service of the statevariable
				if pservice ~= nil then
					local pdevice = self.IDlist[pservice.parent]	-- gets the parent device of the service
					if pdevice ~= nil then
						local devname = pdevice.name or "(unannounced device)"					-- gets the actual device name
						gir.TriggerEvent("UPnP value update " .. devname .. ":" .. svar.name, self.xPL.ID, svar.ID,tostring (v))
                        self:UPnPDeviceVariableUpdate (pdevice,pservice,svar,old)
					else
						-- device not found, assume announcement incomplete, no girder event
					end
				else
					-- service not found, assume announcement incomplete, no girder event
				end
            else
                -- no variable found, not announced yet, so do nothing
			end
		end
	end,

    CallMethod = function (self, method, ...)

        local callback = function (CallID, ...)
            -- this callback will store the results of the call in the ResponseQueue to be picked up
            self:Lock()
            local myCall = self.ResponseQueue[CallID]
            if type(myCall) == "table" then
                -- store results in queue element
                myCall.Results = arg
            else
                -- unknown callid, or not a table, do nothing
            end
            self:Unlock()
        end

        -- start the async call
        local CallID = self:CallMethodAsync(method, callback, unpack(arg))
        local results
        if CallID then
            self:Lock()
            local myCall = self.ResponseQueue[CallID]
            self:Unlock()
            -- wait for response
            local done = false
            while not done do
                win.Sleep(100)
                self:Lock()
                if type(myCall.Results) == "table" then
                    -- type changed to a table, so it now contains the results
                    results = myCall.Results
                    self.ResponseQueue[CallID] = nil
                    done = true
                elseif myCall.TimeOut < date:now() then
                    -- waiting timed out, so exit
                    self.ResponseQueue[CallID] = nil	-- cleanup
                    results = { false, "No response received (time out)" }
                    done = true
                end
                self:Unlock()
            end
            -- we're done, return results
            return unpack(results)
        end
    end,

	CallMethodAsync = function (self, method, callback, ...)
		-- Calls the provided UPnP method using the extra arguments
        -- method: UPnP method table
        -- callback: function to call with the results. Arguments will be;
        --    1) the CallID identifier
        --    2) boolean, success/failure of the call
        --    3 and on) results returned by the call or error messages in case of a failure
        -- returns: a unique CallID, to be returned as the first argument to the callback.

		-- check method
		if method == nil then
			error("No method provided, first argument must be method table", 2)
		elseif method.announce == nil then
			error("Table provided is not a UPnP element", 2)
		elseif method.announce ~= "method" then
			error("UPnP element provided is not a Method", 2)
		end

		-- construct xPL message
		local header = "xpl-cmnd\n{\nhop=1\nsource=%s\ntarget=%s\n}\nupnp.method\n{\ncommand=methodcall\nmethod=%s\ncallid=%s\n"
		local footer = "}\n"
		local body = ""
		for i,v in ipairs(method.order) do
			local t = type(arg[i])
			local value = arg[i]
			-- first convert value to string type
			if t == "string" then
				-- no need to do anything
			elseif t == "number" then
				value = value .. ""
			elseif t == "boolean" then
				if value then
					value = "True"
				else
					value = "False"
				end
			elseif t == "nil" then
				value = ""
			else
				-- function, userdata, thread, and table
				error("Cannot handle type '" .. t .. "' as input parameter for a UPnP methodcall.", 2)
			end
			body = body .. string.format("%s=%s\n", v, value)
		end
		local msg = string.format(header .. body .. footer, self.xPL.Source, method.xpl, method.ID, self.CallID)
		self.xPL:SendMessage(msg)
		self.CallID = self.CallID + 1					-- increase unique ID by 1
        -- create queueitem to wait for the response
        local queueItem = {
            CallID = self.CallID - 1,
            MethodID = method.ID,
            TimeOut = date:now(),
            CallBack = callback,
        }
        queueItem.TimeOut.Second = queueItem.TimeOut.Second + 20
        -- add to waiting queue
		self:Lock()
		self.ResponseQueue[queueItem.CallID] = queueItem
		self:Unlock()
		return queueItem.CallID --self:WaitForResponse(method.ID, self.CallID - 1)
	end,

    HandleMethodResult = function(self, msg)
        -- handle incoming messages with method results
        local callid = self:GetMessageValueByKey(msg, "callid")
        callid = callid and tonumber (callid)
        
        if callid ~= nil then
            if self.ResponseQueue[callid] ~= nil then
                -- its a response we're waiting for, so collect and remove from queue
                local myCall = self.ResponseQueue[callid]
                self.ResponseQueue[callid] = nil
                -- deal with reponse
                local response = {}
                local success = (string.lower(self:GetMessageValueByKey(msg, "success") or "") == "true")
                if not success then
                    -- failed call, report error
                    table.insert(response, false)
                    table.insert(response, self:GetMessageValueByKey(msg, "error") or "No error message was provided")
                else
                    -- successfull call, dissect response
                    -- lookup the method it was a response to
                    local method = self.IDlist[myCall.MethodID]
                    if method == nil then
                        -- something is wrong
                        table.insert(response, false)
                        table.insert(response, "Could not locate method for this reponse message, UPnP device left?")
                    else
                        -- now add success and all OUT parameters to return
                        table.insert(response, true)
                        for n,argID in ipairs(method.order) do	-- loop through the arguments in the correct order as specified
                            if self.IDlist[argID].direction == "out" then
                                -- got an out-going parameter, get value and add it
                                local r = self:GetMessageValueByKey(msg, argID) or ""
                                if r == "<<chopped_it>>" then
                                    -- it was chopped, so we must reconstruct
                                    local c = 1
                                    local kv
                                    r = ""
                                    repeat
                                        kv = self:GetMessageValueByKey(msg, argID .. "-" .. c)
                                        if kv then
                                            r = r .. kv
                                        end
                                        c = c + 1
                                    until kv == nil
                                end
                                -- convert to proper type and add to return list
                                table.insert(response, self:ConvertToType(r, self.IDlist[argID].variable))
                            end
                        end
                    end
                end
                
                -- response table completed, now return the values to the callback function
                if type(myCall.CallBack) == "function" then
                    local result, err = pcall(myCall.CallBack, unpack(response))
                    if not result then
                        print ("Error returned by the callback for a UPnP method call result;")
                        print ("    CallID  : " , myCall.CallID)
                        print ("    MethodID: " , myCall.MethodID)
                        print ("    Error   : " , err)
                    end
                end
            end
        end
    end,

    
	AppendCall = function (self, method)
		-- takes a 'method' table and appends an 'execute' function
		method.execute = function (method, ...) return self:CallMethod(method, unpack(arg)) end
		method.executeasync = function (method, callback, ...) return self:CallMethodAsync(method, callback, unpack(arg)) end
		return method
	end,


	RequestVariableValues = function (self, pID)
		-- Request variable values for this device
		if not table.IsEmpty(self.AnnFragments) then
			-- Announcement fragment list is not empty, so probably we're still in the announcement phase with lots
			-- of traffic, so delay the variable update request
			local ded = Classes.DelayedExecutionDispatcher:New (3000, function () self:RequestVariableValues(pID) end)
		else
			pID = (pID or "") .. ""		-- convert to string
			if pID == "" then
				error("No ID provided for the element to poll for its variables.")
			end
			local dev = self.IDlist[pID]
            if dev then -- make sure device hasn't left
                if dev.announce ~= "device" and dev.announce ~= "service" and dev.announce ~= "variable" then
                    error("Can only request values for types device, service, and variable. Not for type " .. dev.announce)
                end
                local req = "xpl-cmnd\n{\nhop=1\nsource=%s\ntarget=%s\n}\nupnp.basic\n{\ncommand=requestvalue\nid=%s\n}\n"
                local msg = string.format(req, self.xPL.Source, dev.xpl, pID)
                self.xPL:SendMessage(msg)
            end
		end
	end,


	AppendPoll = function(self, element)
		-- append a 'poll' method to the element table
		local id = element.ID
		element.poll = function () self:RequestVariableValues(id) end
	end,


	-- Timer elements to verify completeness of announcement, and request missing elements if necessary
	CheckAnnouncement = function(self)
		-- check whether all announced parts have been completed to complete root-devices
		-- request missing parts if necessary

		local request = {}  -- List with IDs to request

        -- send xplmessage to request single id
        local requestid = function(childid)
            local req = "xpl-cmnd\n{\nhop=1\nsource=%s\ntarget=*\n}\nupnp.basic\n{\ncommand=announce\nid=%s\n}\n"
            local msg = string.format(req, self.xPL.Source, childid)
            self.xPL:SendMessage(msg)
        end

		-- setup local recursive function to check 1 individual part recursively
		local checkpart = nil
		checkpart = function(self, id)
			local part = self.AnnFragments[id]
            -- check parent availability
            if part.parent then
                if self.AnnFragments[part.parent] then
                    -- parent is available (but incomplete), do nothing
                else
                    -- no parent available, must request it then, add parent to the list
                    request[part.parent] = part.parent
                    -- requesting a parent will also automatically announce all children, so no need
                    -- to go check them anymore, just return here.
                    return
                end
            end
            -- check children
			if not table.IsEmpty(part.WaitingFor) then
				for childid, _ in pairs(part.WaitingFor) do
					if self.AnnFragments[childid] then
						-- this child has been announced, but apparently is also incomplete still -> recurse!
						checkpart(self,childid)
					else
						-- this child is unknown to us still, so go add to the request list
						request[childid] = childid
					end
				end
			end
		end

		self:Lock()  --- **** warning, this code in not protected and an error will LOCK UP Girder

		if not table.IsEmpty(self.AnnFragments) then
			-- so we're not complete, go check the announced fragments list

			-- check whether we received anything lately, if not, we've got orphans
			local dl = date:now()
			dl.Second = dl.Second - (3 * announcementtimeout/1000)
			if self.LastFragmentReceived < dl then
				-- nothing was received for 3 x timeout seconds, assume fragment to be orphaned
                while not table.IsEmpty(self.AnnFragments) do
                    for id, part in pairs(self.AnnFragments) do
                        self:DeleteOrphan(part)
                        break   -- exit loop because we're messing with the table while iterating it
                    end
                end
                gir.LogMessage(self.xPL.Name, self.ID .. ' announcement request time-out; removed orphaned elements', 1)
			end

            -- remove any duplicates
			for id, part in pairs(self.AnnFragments) do
				if self.IDlist[id] then
					-- its in both lists, should not occur, but can happen if parts are announced twice
					-- play safe and keep the complete one, delete the new announced part to prevent an
					-- endless loop of re-requesting parts
					self.AnnFragments[id] = nil
                end
			end
            -- go check all remaining parts for completeness
			for id, part in pairs(self.AnnFragments) do
                checkpart(self, id)
            end
            -- do any requests we have to do
            local count = 0
            for id, _ in pairs(request) do
                requestid(id)       -- send xpl message with request
                count = count + 1
            end
            -- signal warning
            if count ~= 0 then
                gir.LogMessage(self.xPL.Name, self.ID .. ' bad announcement, now requesting ' .. tostring(count) ..  ' elements still missing', 1)
            end
			-- set timer again, if still not complete
			if not table.IsEmpty(self.AnnFragments) then
				self:SetAnnouncementTimer()
			end
		end
		self:Unlock()
	end,


	CreateAnnouncementTimer = function(self)
		-- creates the announcement timer at component startup, will NOT arm the timer
		self:DestroyAnnouncementTimer()
		self.AnnouncementTimer = gir.CreateTimer(nil, function() self:CheckAnnouncement() end, nil, false)
	end,


	SetAnnouncementTimer = function(self)
		-- sets the timer to expire in x seconds, and hence go check for announcement completeness
		if self.AnnouncementTimer then
            self.AnnouncementTimer:Cancel()
			self.AnnouncementTimer:Arm(announcementtimeout)
		end
	end,


	DestroyAnnouncementTimer = function(self)
		-- destroys the announcement timer at component stop
		if self.AnnouncementTimer then
			self.AnnouncementTimer:Destroy()
			self.AnnouncementTimer = nil
		end
	end,


    ProcessNewUPnPDevice = function (self,pdevice)
        self:Event (self.Events.DeviceArrived,pdevice)--[[
        if pdevice.type == 'urn:schemas-upnp-org:device:MediaRenderer:1' then
            print ('found av renderer', pdevice.name,pdevice.ID)

            local pservice = pdevice.services ['urn_upnp-org_serviceId_AVTransport']
            if pservice then
                print ('found transport service ',pservice.service)
            end
        end]]
    end,


    ProcessNewUPnPService = function (self,pdevice,pservice)
        --[[if pdevice.type == 'urn:schemas-upnp-org:device:MediaRenderer:1' then
            print ('found av renderer', pdevice.name,pdevice.ID)

            local pservice = pdevice.services ['urn_upnp-org_serviceId_AVTransport']
            if pservice then
                print ('found transport service ',pservice.service)
            end
        end]]
    end,


    UPnPDeviceVariableUpdate = function (self,pdevice,pservice,svar,old)
        --  [[
        --print ('value update',pdevice.name,pservice.service,svar.name,svar.value or '?', '(',old,')')
        --]]
        self:Event (self.Events.DeviceVariable,pdevice,pservice,svar,old)
    end,


    GetUPnPDevice = function (self,UUID)
        return UPnP.devices [UUID] or false
    end,


    GetUPnPDevices = function (self)
        return UPnP.devices 
    end,


} )



-- finally deliver the handler to the xPL component
return myNewHandler
